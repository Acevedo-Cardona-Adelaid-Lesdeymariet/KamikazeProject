# KamikazeProject

## Objetivos ##

### Objetivo General ###

Elaborar un Sistema Domótico enfocado en la seguridad del hogar con ayuda de microcontroladores Arduino, modulos LCD y Teclado Matricial, sensores de proximidad y movimiento (PIR y Ultrasónico), lenguaje de programación C++ y plataformas profesionales  para trabajo colaborativo como GitHub y Tinkercad. 

### Objetivos Específicos  ###

- Aplicar y reforzar los conocimientos adquiridos en diversas asignaturas ofertadas en la Ing. Sistemas Computacionales relacionadas con el tema de microprocesadores y microcontroladores como Principios Eléctricos y Aplicaciones Digitales, Arquitectura de Computadoras, Lenguajes de Interfaz y Sistemas Programables. 
- Implementar aplicaciones computacionales para solucionar problemas de diversos contextos, integrando diferentes tecnologías, plataformas o dispositivos.  
- Diseñar e implementar interfaces y tecnologías para la automatización de sistemas de hardware y desarrollo del software asociado de forma efectiva.
- Coordinar y participar en equipos multidisciplinarios para la aplicación de soluciones innovadoras que ataquen problemáticas de la vida cotidiana. 
- Comprender qué es y cómo funciona el Internet de las Cosas en conjunto con Sensores y Actuadores. 

## Competencias Adquiridas ##

### Competencias Generales ###

- Capacidad para abstraer, analizar, sintetizar, organizar y planificar un proyecto.
- Habilidad para buscar, analizar y clasificar información proveniente de fuentes diversas. 
- Toma de decisiones y solución de problemas de forma colaborativa.
- Capacidad para generar ideas nuevas e innovadoras.
- Capacidad para comunicarse de forma oral y escrita por medios electrónicos. 
- Capacidad para actuar de forma proactiva y productiva ante imprevistos. 
- Capacidad de aplicar los conocimientos en la práctica.
- Búsqueda del logro.

### Competencias Específicas  ###

- Conoce e identifica los componentes y el funcionamiento de diferentes modelos de arquitectura. 
- Identifica los requerimientos de Hardware y realiza un Proyecto de Electrónica en base a ello. 
- Aplica principios físicos y comprende transductores y sensores. 
- Analiza y sintetiza la función de diversos sensores y sus aplicaciones.
- Aplica principios teóricos de electromagnetismo para analizar actuadores.  
- Identifica y diferencia los actuadores eléctricos, mecánicos e hidráulicos.
- Ensambla los circuitos respectivos empleando sensores y actuadores.  
- Identifica las características eléctricas de un microcontrolador.  
- Conoce la arquitectura interna del microcontrolador.  
- Comprende la estructura de registros del microcontrolador.  
- Analiza dispositivos de entrada/salida y puertos del microcontrolador. 
- Utiliza lenguajes ensamblador o de alto nivel como C++ en la programación del microcontrolador.  
- Programa microcontroladores utilizando puertos de E/S.  
- Construye y comprueba circuitos con microcontrolador. 
- Identifica y analiza los elementos esenciales de los puertos y buses de comunicación.  
- Implementa aplicaciones que impliquen el manejo de puertos y buses de comunicación. 

## Problemática  ##

Hoy en día son cada vez más las personas que necesitan instalar un sistema de seguridad en sus hogares, sin embargo muchos de estos van más allá de la clásica cámara de vigilancia y agregan tecnologías IoT como la inteligencia artificial y machine learning, permitiendo la comunicación de dispositivos y sistemas a través de internet como lo son aplicaciones o software especializado, sensores y actuadores. Debido a que se trata de tecnologías relativamente nuevas e innovadoras su costo puede dispararse y ser claramente inaccesibles para aquel público que vive en condiciones de pobreza o en áreas geográficas con altos índices de inseguridad. 

Además, ya que la demanda de estos servicios aumenta, resulta congruente observar que su precio también, esto no sucede porque los servicios esten escaseando como podría llegarse a creer habitualmente, sino que cuando los precios de casi todos los bienes y servicios suben y siguen aumentando debido a un incremento en la cantidad de dinero en circulación, se entiende que la gente tiene más dinero para gastar y va a demandar más productos, y si la cantidad de bienes y servicios en el mercado es la misma, los precios van a seguir elevándose, dado que la cantidad ofrecida no ha aumentado para abastecer el incremento en la demanda.

Tan solo en el 2018 se calculó que el 41.9% de la población mexicana vivía en situación de pobreza, es decir, cerca de 52.4 millones de personas, y desgraciadamente en la mayoría de los casos la delincuencia está estrechamente relacionada con la pobreza, de hecho, tras la llegada del COVID-19 se pudo notar como la cantidad de robos y saqueos a propiedades privadas aumentaron porque muchas personas se quedaron sin trabajo, y por consiguiente, sin dinero para poder subsistir, teniendo que llegar a ciertos extremos. 

Es por ello que la vía mas económica y rápida para poder obtener un sistema de seguridad en estos tiempos de crisis económica y emergencia sanitaria es haciéndolo uno mismo con el material que se tenga a la mano y sin la necesidad de tener demasiados conocimientos sobre electrónica. En nuestro equipo optamos por un sistema domótico construido con componentes relativamente económicos y accesibles, ya que se venden en grandes cantidades tanto en tiendas físicas como en línea y resulta casi imposible que alguna persona no pueda llegar a adquirirlos. También es un sistema completamente modificable y adaptable, teniendo la posibilidad tanto estudiantes, docentes como público en general de emplearlo en el sitio que crea más conveniente o agregarle más funcionalidades si se desea.

## Introducción ##

### ¿Por qué Estudiar y Utilizar Arduino? ###

Arduino es una plataforma de software libre fácil de usar, que permite a los alumnos construir y programar sus propios proyectos. El “37-In-1 Sensor Kit for Arduino” ofrece una amplia variedad de componentes y sensores que permiten conectar el mundo físico con el virtual, desarrollando la concentración y las habilidades manuales. Con Arduino no solo se aprende a programar, sino que también se motiva al alumno a pensar creativamente, analizando situaciones y aplicando el pensamiento crítico y habilidades para resolver problemas reales.

La robótica educativa, dentro de los colegios, nos proporciona una forma creativa de utilizar y comprender las nuevas tecnologías, la posibilidad de implementar soluciones basadas en ingenio y destreza, dejando de ser solamente consumidores.

La Plataforma de Arduino mantiene una posición muy cercana al mundo de la educación, y es de gran uso en los cursos de Secundaria y Bachillerato. Aprender es fácil y, como es habitual, la clave es dar con todas esas webs con recursos, guías y tutoriales para ir avanzando en el aprendizaje de esta plataforma de electrónica. Pero no se trata solo de un proyecto tecnológico, es mucho más, detrás de él existe una comunidad en movimiento y expansión, que incluye programadores, artistas, educadores, científicos, estudiantes, entre muchos otros y que inspira la filosofía de la cultura libre, permitiendo compartir experiencias y resolver problemas vía online. 

### ¿Cuales son los Beneficios de la Robótica en el Aula? ###

Durante el desarrollo de esta asignatura se aprenderá a utilizar una placa Arduino, el entorno de programación y un kit de desarrollo.

En educación pueden diferenciarse dos tipos de uso de la programación y la robótica como apoyo en clase: por un lado, la robótica y la programación educacional, que consiste en un elemento físico o presencial que motiva a los estudiantes a construir, programar y razonar de manera lógica; por otro lado, la programación y la robótica como elemento social, utilizándolo como actividad recreativa o hobbie. 

En referencia al primer tipo de uso, el educacional, las tecnologías de la programacion y robotica son especialmente beneficiosas en la enseñanza de asignaturas como la ciencia, tecnología, ingeniería y matemáticas. Sin embargo, resulta desfavorable centrarse solo en el uso como herramientas de enseñanza en estas materias y no ser también desplegadas para otras asignaturas que permitan utilizarlas como elementos de socialización.

Otro beneficio en el uso de estas herramientas sería en el caso de alumnos con necesidades especiales, tanto en las áreas cognitivas como psicosociales. La potencialidad de las propuestas educativas basadas en robots lo hacen especialmente útil en programas de refuerzo y de educación especial por el tipo de motivación que ofrecen al usuario. 

Estamos convencidos de que los dispositivos tangibles aumentan el nivel de comprensión debido a que los estudiantes están manipulando las cosas en un plano real. Sin embargo, podemos encontrar alumnos que prefieren trabajar con dispositivos no tangibles. Por lo tanto, lo que parece lógico es un enfoque híbrido entre robótica y programación, donde una fusión entre lo físico y lo virtual proporcione más flexibilidad a los docentes y estudiantes. 

La principal suposición de este enfoque es que la interacción con robots puede reforzar los procesos educativos y mejorar los resultados, tales como el aprendizaje conceptual y el entrenamiento cognitivo, motivar a los estudiantes, apoyar la curiosidad y aumentar la conciencia sobre la robótica.

La metodología empleada pretende fomentar las capacidades del alumnado, estimulando la investigación, la observación y la imaginación, así como el hábito de trabajo individual y en equipo. Se procura fomentar actitudes humanísticas como la curiosidad, empatía e integridad, mediante contenidos específicos, actividades y experiencias prácticas. Algunos de estos contenidos contribuyen a la consolidación de varias competencias.

La idea del proyecto surgió debido a la gran inseguridad por la que está cruzando nuestro país actualmente, y que por desgracia, se ha ido agudizando por la crisis sanitaria, económica y social del COVID-19 que ha traído consigo mayores incidencias de robos y saqueos, por ello es que hoy más que nunca el mercado de los sistemas de seguridad tienen muchisimas mas solicitudes y por lo tanto tienden a un crecimiento económico exponencial. También se considera el hecho de que uno de estos sistemas especializados puede ser demasiado costoso y no estar al alcance de todo el público que llegase a necesitarlo, dándose a entender que la solución más viable es realizar uno propio con el material más económico que se pueda encontrar en el mercado, esto en lo que se tienen los ingresos suficientes para adquirirlo con un proveedor de servicios de seguridad. 

En base a estos criterios se llegó a la conclusión de que el proyecto elaborado cumple con características de Domótica, es decir, aquel sistema capaz de automatizar una vivienda o edificación de cualquier tipo, aportando servicios de gestión energética, seguridad, bienestar y comunicación, y que puede estar integrado por medio de redes interiores y exteriores de comunicación, cableadas o inalámbricas, y cuyo control goza de cierta ubicuidad, desde dentro y fuera del hogar. En pocas palabras, se podría definir como la integración de la tecnología en el diseño inteligente de un recinto cerrado. 

Nos hemos basado principalmente en tutoriales de YouTube e Instructables y a partir de ahí hemos ido mejorando la idea e incorporando más cosas. 

Después de escoger este proyecto y avanzar bastante en la codificación, hemos encontrado en YouTube circuitos muy parecidos al que deseábamos realizar, como por ejemplo,[ el que se presenta aquí.](https://www.youtube.com/watch?v=dRCnccv_dVE)

Como se puede apreciar en la imagen anterior la diferencia más notoria es que en ese proyecto se incorporan cámaras en lugar de utilizar Sensores PIR y de Ultrasonidos. A pesar de ello, la idea general de cómo disponer los elementos en el circuito eléctrico para el proyecto final la hemos sacado de ese video. 

## Descripción del Proyecto ##

Este proyecto tiene como objetivo elaborar una alarma doméstica junto con un sistema de detección de intrusos que permita avisar al usuario de la intromisión de agentes externos en su domicilio. 

La realización de dicho proyecto se ha llevado a cabo por un equipo compuesto de 4 integrantes y se ha dividido en 5 prácticas:

- **Práctica 1:** Módulo Sensor Ultrasónico.
- **Práctica 2:** Módulo Sensor PIR.
- **Práctica 3:** Montaje de Ambos Sensores.
- **Práctica 4:** Teclado Matricial y Pantalla LCD.
- **Práctica 5:** Conexión de 2 Arduinos UNO.

El desarrollo de las prácticas y su unificación conforman el proyecto final, cumpliendo con el objetivo que se perseguía y permitiendo que los miembros del equipo trabajen de forma autónoma en cada parte. 

El funcionamiento de la alarma doméstica permitirá realizar configuraciones en el dispositivo para poder ejecutar varias acciones como: 

1. Activar Alarma Completa.
2. Activar ½ Alarma.
3. Cambiar de Contraseña.

Más adelante se explicará a detalle en qué consisten cada una de estas funciones. 

## Tecnologías y Materiales Empleados  ##

A pesar de que más adelante se explicará qué tipos de materiales se han utilizado y cómo se van integrando al circuito, aquí incluimos a modo de resumen la lista de todos aquellos que hemos empleado para llevar a cabo nuestro proyecto final:

- 2 Arduino UNO.
- 2 Protoboard.
- 3 LEDs Rojos.
- 1 LED Verde.
- 1 LED Amarillo.
- 1 Buzzer.
- 1 KeyPad 4x4.
- 1 LCD 16x2.
- 7 Resistencias de 220 Ω.
- 1 Potenciómetro de 250 kΩ.
- 1 Módulo de Sensor Ultrasonico HC-SR04.
- 2 Sensores PIR HC-SR501.
- Cables de Conexión.
- Cables de Hembra a Macho DuPont.
- Alimentación: Ordenador o PowerBank con Conexión para 2 Puertos USB.

También hemos empleado las siguientes plataformas:

- **Desarrollo:**
  1. Arduino IDE.
  2. Tinkercad Circuits.
- **Investigación:**
  1. Instructables.
  2. YouTube.
  3. StackExchange.
  4. StackOverflow.
  5. Hackaday.
  6. Hackster.
  7. Arduino Project Hub.
- **Comunicación (Trabajo Colaborativo):**
  1. Google Meet.
  2. Google Docs.
  3. Google Drive.
  4. Discord.
  5. Facebook Messenger.
  6. GitHub.
  7. Trello.

## Costos ##

## Montaje del Proyecto ##

### Practica 1: Sensor Ultrasónico  ###

<p align="center">
<img src="https://2.bp.blogspot.com/-f45ht1KiLKY/WEPuVRaHbkI/AAAAAAAAFXU/1rS9kibzqk8xse9Pem4oCIUTgIJW1EWEACLcB/s1600/modulo-HC-SR04-arduino-2.jpg" alt="Sensor Ultrasónico" width="250"/>
</p>

#### Descripción de la Práctica ####

El objetivo principal de esta práctica es aprender a utilizar el módulo sensor de ultrasonido. El sensor de ultrasonido es el responsable de medir distancias para evitar obstáculos.

En lugar de utilizar el sensor de ultrasonido de forma independiente, se han asociado dos led, uno de color rojo y otro de color verde; y un zumbador de sonido (más adelante buzzer). Cuando el sensor detecte movimiento, se encenderá el led rojo y el buzzer emitira sonido. En caso de no detectar movimiento, permanecerá encendido el led de color verde.

#### Material Utilizado ####

- 1 Arduino UNO.
- 1 Protoboard.
- 1 Módulo de Sensor Ultrasonico HC-SR04.
- 1 LED Rojo.
- 1 LED Verde.
- 1 Buzzer.
- 2 Resistencias 220 Ω.
- 9 Cables de Hembra a Macho DuPont.

#### Descripción del Componente ####

El módulo HC-SR04 es un sensor de distancias por ultrasonidos capaz de detectar objetos y calcular la distancia a la que se encuentra en un rango de 2 a 450 cm. El sensor funciona por ultrasonidos y contiene toda la electrónica encargada de hacer la medición. Su uso es tan sencillo como enviar el pulso de arranque y medir la anchura del pulso de retorno.

El sensor incorpora un par de transductores de ultrasonido que se utilizan de manera conjunta para determinar la distancia del sensor con un objeto colocado enfrente de este. La interfaz digital se logra mediante 2 pines digitales: el pin de trigger (disparo) y echo (eco).

1.	El primero recibe un pulso de habilitación de parte del microcontrolador, mediante el cual se le indica al módulo que comience a realizar la medición de distancia.
2.	El segundo Pin (echo) del sensor “muestra” al microcontrolador un pulso cuyo ancho es proporcional al tiempo que tarda el sonido en viajar del transductor al obstáculo y luego de vuelta al módulo.

#### Simulación ####

En este apartado podemos ver la simulación de la práctica en el programa Tinkercad.

En la **imagen 1**, se aprecia que el ultrasonido está encendido y el led está en verde porque no detecta ningún obstáculo en una distancia mayor a 200 cm.

En la **imagen 2**, se aprecia que el ultrasonido y led rojo están encendidos porque se detecta un obstáculo en una distancia igual o inferior a 200 cm. En este caso, el buzzer emite sonido para que se identifique la presencia de un obstáculo.

##### Imagen 1 #####

##### Imagen 2 #####

#### Código Fuente ####

Después de efectuar el cableado, se abre el programa “IDE de Arduino” y escribimos este código para que la placa Arduino R1 reconozca las diferentes partes de la práctica, e interactúen como se ha descrito anteriormente. Una vez escrito el código lo subimos a la placa y comprobamos que funciona. 

```cpp
int ledPinRojo = 10;
int ledPinVerde = 12;
int pinBuz = 6; 
int ultrasonido = 9;

void setup()
{
    Serial.begin(9600);
    pinMode(ledPinRojo, OUTPUT);
    pinMode(ledPinVerde, OUTPUT);
}

long readUltrasonicDistance(int pin)
{
    pinMode(pin, OUTPUT);
    digitalWrite(pin,LOW);
    delayMicroseconds(2);
    digitalWrite(pin,HIGH);
    delayMicroseconds(10);
    digitalWrite(pin, LOW);
    pinMode(pin, INPUT);
    return pulseIn(pin, HIGH);
}

void loop()
{
    // Leemos la Distancia del Sensor Ultrasónico.
    int cm = 0.01723*readUltrasonicDistance(ultrasonido);
  
    // Si la Distancia es menor a 2 metros, encendemos el Led Rojo y apagamos el Verde.
    // Además, hacemos sonar el Buzzer.
    if (cm < 200)
    {
        tone(pinBuz, 350, 200);
        digitalWrite(ledPinRojo, HIGH);
        Serial.println("Motion detected!");
        digitalWrite(ledPinVerde, LOW);
    }
    else
    {
        // En caso contrario, apagamos el Led Rojo y encendemos el Verde.
        digitalWrite(ledPinRojo, LOW);
        digitalWrite(ledPinVerde, HIGH);
    }
}
```
### Práctica 2: Sensor PIR ###

<p align="center">
<img src="https://www.puntoflotante.net/SENSOR-HC-SR501-1000-M.jpg" alt="Sensor PIR" width="300"/>
</p>

#### Descripción de la Práctica ####

El objetivo principal de esta práctica es aprender a utilizar el módulo sensor PIR. El sensor PIR es el responsable de detectar el movimiento de un objeto. 

En lugar de utilizar el Sensor PIR de forma independiente, se han asociado dos LED (uno de color rojo y otro de color verde) y un buzzer. Cuando el sensor detecte movimiento, se encenderá el LED Rojo y el Buzzer emitira sonido. En caso de no detectar movimiento, permanecerá encendido el LED de color Verde.

#### Material Utilizado ####

-	1 Arduino UNO.
-	1 Protoboard. 
-	1 Sensor PIR.
-	1 LED Rojo.
-	1 LED Verde.
-	1 Buzzer.
-	2 resistencias de 220 Ω.
-	11 Cables de Hembra a Macho DuPont.

#### Descripción del Componente ####

El Módulo PIR HC-SR501, es un sensor electrónico pasivo que mide la luz infrarroja (IR) emitida por los objetos situados en su campo de visión. Se utilizan principalmente en los detectores de movimiento basados en PIR. 

Todos los objetos con una temperatura por encima del cero absoluto emiten calor. Por lo general, esta radiación es invisible para el ojo humano, ya que irradia en longitudes de onda infrarrojas, pero puede ser detectado por dispositivos electrónicos diseñados para tal propósito.

El término pasivo, en este caso, se refiere al hecho de que los dispositivos PIR no generan o irradian cualquier energía para fines de detección. Trabajan en su totalidad para la detección de la energía emitida por otros objetos. Es importante tener en cuenta que los sensores PIR no detectan o miden "calor" sino que detectan la radiación infrarroja emitida por un objeto. Sin embargo, a pesar de ser diferentes, a menudo la radiación infrarroja está asociada a la temperatura del objeto.

El sensor incorpora tres pines de conexión +5V, OUT (3,3v) y GND, y dos resistencias variables de calibración (Ch1 y RL2).

1.	**Ch1:** Esta resistencia permite establecer el tiempo que se va a mantener activa la salida del sensor. Una de las principales limitaciones de este módulo es que el tiempo mínimo que se puede establecer es de más o menos 3s. Si se cambia la resistencia por otra de 100K, puede bajar el tiempo mínimo a más o menos 0,5 s.
2.	**RL2:** Esta resistencia variable permite establecer la distancia de detección, que puede variar entre 0 a 3 metros.

#### Simulación ####

En este apartado podemos ver la simulación de la práctica en el programa Tinkercad. 

En la **imagen 1**, se aprecia que el sensor PIR está encendido y el led está en verde porque no detecta ninguna temperatura. 

En la **imagen 2**, se aprecia que el sensor PIR está encendido y el led está rojo porque detecta una temperatura. En este caso, el buzzer emite sonido para que se identifique la presencia de un cuerpo. 

##### Imagen 1 #####

##### Imagen 2 #####

#### Código Fuente ####

Después de efectuar el cableado, se abre el programa “IDE de Arduino” y escribimos este código para que la placa Arduino R1 reconozca las diferentes partes de la práctica, e interactúen como se ha descrito anteriormente. Una vez escrito el código lo subimos a la placa y comprobamos que funciona.

```cpp
int ledR = 10; //led rojo
int ledV = 12; //led verde
int pir = 7; // PIR
int buzzer = 6; //Buzzer

void setup(){
  //iniciación de los sensores leds
  Serial.begin(9600);
  
  pinMode(pir, INPUT_PULLUP);
  pinMode(ledR, OUTPUT);
  pinMode(ledV, OUTPUT);
}

void loop(){
  //Leemos los valores del Sensor PIR
  int proximidad = digitalRead(pir);
  delay(100);
  
  //si detecta movimiento encendemos el led rojo y el buzzer, 
  //luego apagamos el led verde
  
  if (proximidad == HIGH){
    tone(buzzer,350,200);
    digitalWrite(ledR, HIGH);
    Serial.println("Movimiento Detectado!");
    digitalWrite(ledV, LOW);
  }
  else{
    //si no apagamos todo y dejamos encendido el verde :)
    digitalWrite(ledR, LOW);
    digitalWrite(ledV, HIGH);
  }
}
```

### Práctica 3: Integración de Sensores PIR y Ultrasonido ###

#### Descripción de la Práctica ####

El objetivo principal de esta práctica es integrar las dos prácticas anteriores. En lugar de utilizar los sensores de movimiento por separado, queremos hacer que cada uno de los sensores de movimiento tengan un led rojo asociado. Cuando un sensor detecte movimiento, se encenderá su propio led rojo, a modo de indicación para saber cuál es el sensor que está detectando movimiento. Por ello, tenemos 3 sensores y 3 leds rojos. Finalmente, dispondremos de un led verde, que se encenderá si ninguno de los tres sensores están detectando movimiento. 

Esta práctica la hacemos con el objetivo de que luego en nuestro proyecto final seamos capaces de diferenciar en qué habitación de la casa están los intrusos. 

#### Material Utilizado ####

-	1 Arduino UNO.
-	1 Protoboard.
-	2 Sensores PIR.
-	1 Sensor de Ultrasonido.
-	3 LEDS Rojos.
-	1 LED Verde.
-	1 Buzzer
-	4 Resistencias de 220 Ω.

#### Simulación ####

En este apartado podemos ver la simulación de la práctica en el programa Tinkercad. La primera imagen muestra la simulación con todos los sensores desactivados salvo el LED verde, que indica que no se están detectando intrusos en el sistema:

La siguiente imagen muestra la simulación cuando dos de los sensores están detectando intrusos. Como podemos ver, dos de los leds rojos están activados a modo indicativo: 

#### Código Fuente ####

```cpp
int ledPinRojo = 8 ;
int ledPinRojo2 = 10;
int ledPinRojo3 = 11;
int ledPinVerde = 12;
int pirPin = 7;
int pirPin2 = 13;
int pinBuz = 6;
int ultrasonido = 9;

void setup()
{
  Serial.begin(9600);
  pinMode(pirPin, INPUT_PULLUP);
  pinMode(pirPin2, INPUT_PULLUP);
  
  pinMode(ultrasonido, INPUT);
  
  pinMode(ledPinRojo,OUTPUT);
  pinMode(ledPinRojo2,OUTPUT);
  pinMode(ledPinRojo3,OUTPUT);
  pinMode(ledPinVerde,OUTPUT);
  
}

long readUltrasonicDistance( int pin)
{
pinMode(pin,OUTPUT);
digitalWrite(pin,LOW);
delayMicroseconds(2);

digitalWrite(pin,HIGH);
delayMicroseconds(10);
digitalWrite(pin,LOW);
pinMode(pin,INPUT);
  
return pulseIn(pin,HIGH);

}

bool intrusos = false;

void loop()
{
  bool desactivado = false;
  
  int proximity = digitalRead(pirPin);
  delay(100);
  
  int proximity2 = digitalRead(pirPin2);
  delay(100);
  
  int cm = 0.01723 * readUltrasonicDistance(ultrasonido);
  Serial.println(cm);
  
if(proximity == HIGH)
  {
  
  tone(pinBuz, 350,200);
  digitalWrite(ledPinRojo, HIGH);
  Serial.println("Motion detected");
  digitalWrite(ledPinVerde,LOW);
  intrusos = true;
  
  }
  else
  {
  digitalWrite(ledPinRojo,LOW);
    desactivado = true;
  }
  
  if(proximity2 == HIGH)
  {
  tone(pinBuz, 350,200);
  digitalWrite(ledPinRojo3, HIGH);
  Serial.println("Motion detected");
  digitalWrite(ledPinVerde,LOW);
  intrusos = true;
  desactivado = false;
  }
  
  else
  {
  digitalWrite(ledPinRojo3,LOW);
  }
    
    if(cm < 200){
      tone(pinBuz, 350,200);
      digitalWrite(ledPinRojo2, HIGH);
      Serial.println("Motion detected");
      digitalWrite(ledPinVerde, LOW);
      intrusos = true;
    }
   else
   {
     digitalWrite(ledPinRojo2 , LOW);
     
     if(desactivado == true) 
     {
     intrusos = false;
     }
   }
  
      if(intrusos == false) 
      {
      digitalWrite(ledPinVerde , HIGH);
      }
      
    }
```

### Práctica 4: Pantalla LCD 16x2 y KeyPad 4x4 ###

#### Descripción de la Práctica ####

El objetivo principal de esta práctica es aprender a utilizar periféricos de entrada y salida de datos. Para ello utilizaremos un teclado matricial como dispositivo de entrada, el cual permitirá la introducción de claves numéricas, y una pantalla LCD como dispositivo de salida, donde se mostrará al usuario una serie de instrucciones y los números que el usuario haya introducido. 

Al inicio, tendremos programada una clave numérica, un led rojo encendido, y se mostrará por la pantalla LCD un mensaje el cual indique al usuario que el sistema se encuentra a la espera de que introduzca una clave. Cuando el usuario introduzca una clave numérica, la cual se mostrará por la pantalla, podrán ocurrir 2 estados:

1.	**Clave Numérica Incorrecta:** Se mostrará un mensaje por la pantalla LCD que indique dicho estado y un buzzer producirá un sonido distintivo para este estado. 
2.	**Clave Numérica Correcta:** Se mostrará un mensaje por la pantalla LCD que indique dicho estado, se apagará el led rojo y se encenderá el led verde, y un buzzer producirá un sonido distintivo para este estado. 

Esta práctica la hacemos con el objetivo de que luego en nuestro proyecto final seamos capaces de interactuar con el sistema de control de la alarma. 

#### Material Utilizado ####

-	1 Arduino UNO.
-	1 Protoboard.
-	1 Keypad 4x4.
-	1 LCD 16x2.
-	1 LED Rojo.
-	1 LED Verde.
-	1 Buzzer.
-	4 Resistencias de 220 Ω.
-	1 Potenciómetro 250 kΩ.

#### Descripción del Componente ####

Un teclado matricial es un dispositivo que agrupa los pulsadores en filas y columnas, formando una matriz, y permite controlarlos empleando un número de conductores inferior al que necesitaríamos al usarlos de forma individual. 

La pantalla LCD (Liquid Crystal Display) muestra información en una pantalla gracias a la iluminación del fondo. Para ajustar dicha iluminación suele ser necesario el uso de un potenciómetro que permita regular la resistencia entre la placa Arduino y el LCD. La pantalla que utilizaremos en esta práctica es de 16x2, es decir, tiene 2 filas de 16 caracteres cada una. 

#### Simulación ####

En este apartado podemos ver la simulación de la práctica en el programa Tinkercad. La primera imagen muestra la simulación del sistema a la espera de que el usuario introduzca una clave:

**Estado 1:** Introducción de Clave Numérica Incorrecta

**Estado 2:** Introducción de Clave Numérica Correcta (2255)

#### Código Fuente ####

```cpp
//Librerías necesarias
#include <LiquidCrystal.h>
#include <Keypad.h>
/*---------------------KEYPAD---------------------------*/
const byte numRows=4;//Número de filas
const byte numCols=4;//Número de columnas
char keypressed;
char keymap[numRows][numCols]=
{
  {'1','2','3','A'},
  {'4','5','6','B'},
  {'7','8','9','C'},
  {'*','0','#','D'},
};

//Conexiones entre el teclado y los terminales de arduino
byte rowPins[numRows]={7,6,A5,A4};//Filas de 0 a 3
byte colPins[numCols]={A3,A2,A1,A0};//Columnas de 0 a 3

Keypad myKeypad = Keypad(makeKeymap(keymap), rowPins, colPins, numRows, numCols);
/*--------------------FIN KEYPAD-----------------------*/
/*--------------------LCD------------------------------*/
LiquidCrystal lcd(8,9,10,11,12,13);//Pines (rs,eb,d4, d5, d6,d7)

//Resolución de la pantalla
int screenWidth = 16;
int screenHeight = 2;
/*--------------------FIN LCD-------------------------*/

char codigoSecreto[4] = {'2','2','5','5'};//Clave numerica
//Variables de comparación entre clave introducida y programada
int posicion=0;
int clave=0;

int cursor=5; //Posición de introducción de datos en el LCD

//Declaración de variables auxiliares
int ledRojo=2;
int ledVerde=3;
int buzzer=4;

void setup()
{
  //Inicializamos los leds y el buzzer
  pinMode(ledRojo, OUTPUT);
  pinMode(ledVerde, OUTPUT);
  pinMode(buzzer, OUTPUT);
  
  digitalWrite(ledRojo,HIGH);//Encendemos el LED rojo
  digitalWrite(ledVerde,LOW);//Apagamos el LED verde
  
  //Inicializamos el LCD
  lcd.begin(screenWidth, screenHeight);
  lcd.clear();//Borramos
  lcd.setCursor(0,0);//Situamos el cursor en la línea 1
  lcd.print("Introduzca clave");//Escribimos
  lcd.setCursor(cursor,1);//Situamos el cursor en la línea 2
}

void loop()
{
 char pulsacion = myKeypad.getKey();//Leemos la pulsación
 if(pulsacion!=0)//Si hemos pulsado
 {
   if(pulsacion != '#' && pulsacion != '*' && clave == 0)//Y no ha sido # (almohadilla) ni * (asterisco)
   {
     lcd.print(pulsacion);//Escribimos la pulsación
     cursor++;//Incrementamos la posición del cursor
     //Tono de pulsación
     tone(buzzer,350);
     delay(200);
     noTone(buzzer);
     
     if (pulsacion == codigoSecreto[posicion])//Si la pulsación se corresponde con la clave
     {
       posicion ++;//Incrementamos la posición a comparar
     }
     if (posicion == 4)// Si todas las pulsaciones coinciden con la clave
     {
       lcd.clear();//Borramos
       lcd.setCursor(0,0);//Situamos el cursor en la línea 1
       lcd.print("Clave correcta");//Escribimos
       //Tono de clave correcta
       delay(2000);
       tone(buzzer,500);
       delay(100);
       noTone(buzzer);
       tone(buzzer,600);
       delay(100);
       noTone(buzzer);
       tone(buzzer,800);
       delay(100);
       noTone(buzzer);
       
       clave=1;//Indicador de clave correcta
       
       digitalWrite(ledRojo,LOW);//Apagamos el LED rojo
       digitalWrite(ledVerde,HIGH);//Encendemos el LED verde
     }
     if(cursor>8)//Si hemos pulsado 4 números
     {
       //Inicializamos las variables
       cursor=5;
       posicion=0;
       if(clave==0)//Y la clave no es correcta
       {
         lcd.clear();//Borramos
         lcd.setCursor(0,0);//Situamos el cursor en la línea 1
         lcd.print("Clave incorrecta");//Escribimos
         //Tono de clave incorrecta
         tone(buzzer,70,500);
         delay(250);
         noTone(buzzer);
         delay(1500);
         lcd.clear();//Borramos
         lcd.setCursor(0,0);//Situamos el cursor en la línea 1
         lcd.print("Introduzca clave");//Escribimos
         lcd.setCursor(5,1);//Situamos el cursor en la línea 2
       }
     }
   }
 }
  if(pulsacion=='*')//Si pulsamos * (asterisco)
  {
    //Inicializamos las variables 
    posicion =0;
    cursor=5;
    clave=0;
    posicion=0;
    
    lcd.clear();//Borramos
    lcd.setCursor(0,0);//Situamos el cursor en la línea 1
    lcd.print("Introduzca clave");//Escribimos
    lcd.setCursor(5,1);//Situamos el cursor en la línea 2
    
    digitalWrite(ledRojo,HIGH);//Encendemos el LED rojo
    digitalWrite(ledVerde,LOW);//Apagamos el LED verde
  }
}
```

### Práctica 5: Conexión entre los dos Arduinos ###

#### Introducción ####

El motivo fundamental por el cual utilizamos dos arduinos parte de la necesidad de utilizar más pines para nuestro proyecto sin hacer cosas excesivamente complicadas. 

Aunque la explicación completa de esto sea algo complicado, vamos a intentar reducirlo para que se entienda la forma de usarlo. 

La idea básica es que exista un **protocolo de comunicación entre los dos arduinos** para que sean capaces de “entender el idioma del otro arduino”. ¿Qué significa esto? 

1.	**Cada arduino tiene que tener su propio código fuente** (archivo .ino distinto). Por tanto, habrá que tener dos instancias de Arduino IDE abiertas y cargar en cada Arduino su código correspondiente. 

>**Nota:** cada vez que se añade un nuevo Arduino en Tinkercad, aparece una nueva pestaña desplegable que te permite ver el código asociado al Arduino que acabamos de añadir. 

2.	**El protocolo de comunicación implica que se va a decidir**, un “idioma” que entenderán los dos arduinos. Este idioma será como un **código** entre ellos para comunicar qué cosas están pasando en su placa. Por ejemplo, puede tener sentido que si tenemos conectado un sensor de ultrasonidos al Arduino número 1, quizás queramos comunicarle a un led que está conectado al Arduino número 2 que tiene que encenderse si se detecta presencia a menos de 1 metro. Se detalla la manera un poco más adelante. 

Pasamos ahora a detallar las conexiones que habrá que realizar entre los dos arduinos para que todo lo anterior sea factible.

#### Detalles de la Conexión Entre los dos Arduinos ####

Nosotros utilizamos la información de [Arduino to Arduino Serial Communication](http://robotic-controls.com/learn/arduino/arduino-arduino-serial-communication) para aprender cómo comunicar nuestros arduinos entre ellos.

Suponemos que nos encontramos en la situación descrita en el punto 2 de la introducción del apartado anterior, donde queremos comunicar un arduino que tiene conectado un sensor de ultrasonidos con un arduino que tiene conectado un led, con la idea de que el led se encienda si se está detectando la presencia de alguien. Para ello, las conexiones que tenemos que realizar son las siguientes:

Es decir, tenemos que conectar en serie el pin tx del arduino 1 al pin rx del arduino 2, y el pin tx del arduino 2 al pin rx del arduino 1. 

Adicionalmente, es **MUY importante** que tengan en común un **ground**, tal y como se muestra en la figura. De lo contrario, el proyecto no funcionará. 

#### Ejemplo de Uso ####

Mostramos aquí un ejemplo que ilustra cómo estamos utilizando esto en nuestro proyecto: 

##### Arduino 1 (Envía Información) #####

```cpp
int rx = 0;
int tx = 1;

void setup()
{
  Serial.begin (112500);
  //Inicializa pines UART
  pinMode (rx, OUTPUT);
  pinMode (tx, INPUT);
}

void loop()
{
  byte dataR = 0; //Se manda un 0 por el puerto serial
  // al arduino receptor de información. 
  Serial.print(dataR);
}
```

##### Arduino 2 (Recibe Información) #####

```cpp
int rx = 0;
int tx = 1;

void setup()
{
  Serial.begin (112500);
  //Inicializa pines UART
  pinMode (rx, OUTPUT);
  pinMode (tx, INPUT);
}

void loop()
{
  if(Serial.available() > 0)
  {
    val = Serial.read(); // Lee el siguiente byte
    if (val == '0')
    {
      // Hace algo.
    }
  }
}
```

#### Guía para Descargar el Código en Cada uno de los Arduinos ####

Este apartado es especialmente importante, ya que nosotros tuvimos muchos problemas para conseguir cargar el código en los dos arduinos de forma correcta. 

Los pasos a seguir son los siguientes: 

**Paso previo MUY importante:** Desconectar los cables que unen los pines tx y rx del Arduino. Si están conectados entre sí, el programa nos dará un error y no nos permitirá cargar el código en el Arduino. Una vez desconectados, podemos continuar: 

1.	Conectar el primero de los arduinos al puerto USB del ordenador. 
2.	Abrir Arduino IDE con el código del arduino correspondiente. 
3.	Escoger en Herramientas el tipo de placa y el puerto correspondiente a Arduino:
4.	Pinchar en el botón de subir a la placa, que está en la parte superior de la pantalla: 
5.	Si hay algún error en el código, revisarlo y modificarlo para que el código sea correcto. 
6.	Si no hay ningún error, ya podemos desconectar nuestro Arduino del ordenador. 
7.	Conectar el segundo de los Arduinos. Si lo conectamos en el mismo puerto, no será necesario volver a repetir el punto 3. Esto es más fácil de hacer así que si conectamos los dos arduinos a la vez, ya que al escoger el puerto sólo se puede escoger uno, y posiblemente no estaremos seguros de cuál es cuál. 
8.	Abrir en Arduino IDE el código correspondiente al segundo de los arduinos. 
9.	Volver a repetir los puntos 3 y 4 si fuera necesario. 
10.	Repetir los puntos 5 y 6. 
11.	Finalmente, volver a conectar correctamente los pines tx y rx de cada uno de los arduinos entre ellos. 
12.	Alimentar el circuito y ¡probar el resultado!

